# cosi

## basics

cosi is a low level bytecode with high level semantics. rather than being
designed for fast interpretation, it is designed as a simple language to be
easily generated by language front ends, while maintaining enough information
to be compiled to efficient machine code. although it is not intended to be
written by hand, it's textual representation is intended to look like a high
level language.

```
# lines starting with `#` are comments and are ignored

# items are prefixed with `@` and local variables are prefixed with `%`
## a cosi function
@add (i64 %1, i64 %2) -> (i64)
    i64 %3 = add %1 %2
    ret %3
```

variables are of the form `%N`, where N is an incrementing ID. `%0` is reserved
for an optional context variable. cosi variables are strongly typed, allowing
for the types of instructions to be implicitly typed based on their arguments.

## types

cosi programs work on the following primitive types.

### unit

`unit` repesents the absense of a specific value and has the single value of
unit.

### integers 

`i8, i16, i32, i64`

integers are neither signed nor unsigned. their signedness is determined by the
instructions that use them.

`word, half`

wobbly sized integers dependant on the CPU architecure
(e.g. 64/32 or 32/16 bit on 64-bit and 32-bit architecures respectively)

### floats

`f32, f64`

IEEE 754 single and double floating point numbers.

### blocks

`b8, b16, b272`

blocks are series of contiguous bytes. they are not a primitive type and cannot
be used in function signaures. when referenced, they act as pointers.

```
%1 b128
%1 [0] = i64 123
%1 [64] = f64 1.23
```

### user types

`$MyType ..`

user types are prefixed with `$`. Function bodies do not directly use these
types and they are used for documentation and ABI purposes.

all types are equivalent to a block type of the same size, although can be used
in function signatures.

```
%1 $MyType
%1 [0] = i64 123
%1 [64] = f64 1.23
```

#### tuples

it is possible to group multiple types between parenthesis.

`$MyType (a i32, b f64, c f32, d i8)`

fields are accessed by their offset. in the above type, `c` is at an offset of
128 bytes (with padding) and so can be accessed with:

field names are optional and are only used for documentation

```
@get_c (%1 $MyType) -> f32
    %2 f32 = peek f32 %1 offset 128
    ret %2
```

#### arrays

`$MyArray i32*5`

the above is an array of 5 `i32`s. this is equivalent to the following tuple:

`$MyArray (i32, i32, i32, i32, i32)`

#### unions

`$MyUnion i32 | f32 | (i32, f32)`

all members of a union share the same memory. unions are tagged and uses an
integer to determine the current variant.

`$MyUnion` is equivalent to the following tuple:

`$MyUnion (i8, b64)`

where the tag is the smallest integer that can hold all variants, usually 1 or
2 bytes and the data is the size of the largest variant.

### pointers

```
$Parent ($Child ptr, i32)
$Child (i32, f32)

@get_float (%1 $Parent) -> f32
    %2 ptr = ptr %1 [0]
    %3 f32 = f32 %2 [32]
    ret %3
```

pointers are typed in their definitions (`$Child ptr`) but become anonymous
when used in function bodies (`ptr`).

## data

```
# external functions
@puts (ptr) -> i32

# array definitions
@hello_array i8*6 (0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x00)
@hello_string ", cosy world u_u\n\0"

@main () -> i32
    call @puts @hello_array
    call @puts @hello_string
    ret i32 0
```

## instructions

### memory

```
%1 [0] = i32 123 # writing to address
%2 = i32 %1 [0]  # reading from address
```

reading and writing to memory are done through pointers, followed by an offset

### arithmetic

```
%1 = add i32 %2 %3
%1 = sub i32 %2 %3
%1 = mul i32 %2 %3
%1 = div i32 %2 %3
%1 = udiv i32 %2 %3

%1 = rem i32 %2 %3

%1 = or i32 %2 %3
%1 = and i32 %2 %3
%1 = xor i32 %2 %3

%1 = shl i32 %2 %3 # shift left
%1 = shr i32 %2 %3 # shift right
%1 = sar i32 %2 %3 # shift arithmetic right
```
